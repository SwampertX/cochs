import "pair.coc" {pair head tail}
import "Bool.coc" {Bool true false}
import "equality.coc" {equality reflexivity}

// We need to quantify over the domain that we're composing over
define Nat =
{\D:*.
 // Now we encode the meaning of "natural number", that is,
 // it takes in a function over this domain
 // and returns a function and returns a function over this domain.
 (D->D)->(D->D)};

define zero =
(\D:*.(\f:D->D.(\x:D.
                x)));

define succ =
(\n:Nat.(\D:*.(\f:D->D.(\x:D.f (n D f x)))));

define one =
succ zero;

define two =
succ one;

define three =
succ two;

define four =
succ three;

define five =
succ four;

define pred =
(\n:Nat.
 head Nat Nat
 (n
  (PairOf Nat Nat)
  (\p:(PairOf Nat Nat).
   pair Nat Nat
   (tail Nat Nat p)
   (succ (tail Nat Nat p)))
  (pair Nat Nat zero zero)));

define add =
(\a:Nat.
 (\b:Nat.
  a Nat succ b));

define mult =
(\a:Nat.
 (\b:Nat.
  (\D:*.
   a D (add b) zero)));

define exp =
(\a:Nat.
 (\b:Nat.
  (\D:*.
   b (D->D) (a D))));

define iszero =
(\n:Nat.
 n Bool (\_:Bool.false) true);

define ifzero =
(\n:Nat.
 (\A:*.
  (\ifiszero:A.
   (\ifnotzero:A.
    n A (\_:A.ifnotzero) ifiszero))));

define commutativityaddsucc =
{\a:Nat.
 {\b:Nat.
  (equality Nat (add (succ a) b) (succ (add a b)))}};

define addsuccab = (\a:Nat.(\b:Nat.(add (succ a) b)));
define succaddab = (\a:Nat.(\b:Nat.(succ (add a b))));

define commutativityaddsuccproof =
(\p:commutativityaddsucc.p)
(\a:Nat.
 (\b:Nat.
   reflexivity Nat (add (succ a) b)));

define tests =
(\exp22:Nat.
 (\pred0:Nat.
  (\pred1:Nat.
   (\pred2:Nat.Nat))))
(exp two two)
(pred zero)
(pred one)
(pred two);
