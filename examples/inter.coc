// Idea is if we have P = A -> *,
// then we can ask ourselves if the type (P x) : * is inhabited.

// So if types are true/false depending on if they are inhabited,
// then P is some proposition
// that is true/false depending on what its argument is.

// inter is about taking some propclass as input,
// which is supposed to be some
// proposition of propositions P = (A -> *) -> *
// aka some class of propositions
// (you give me a proposition i'll tell you if it's inside my class)

// Then we want to return the "intersection" proposition,
// some proposition meaning it has type A -> *,
// such that it's only true
// whenever every other proposition in our class is true,
// for any given parameter a : A.

// inter =
(\A0:*.

(\propclass:(A0->*)->*.
(\term:A0.

// This is the type we want to be inhabited
// iff term satisfies the proposition (inter propclass),
// which means we want this type to be inhabited
// iff forall P,
//   (P satisfies propclass) => (term satisfies P).

// Here's the forall P,
{\P:A0->*.

// if P is in propclass
{\arbitraryprop:(propclass P).

// then term satisfies P
(P term)

}
}

)
)

)
