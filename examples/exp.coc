// This exponentiates two Nats together

(\ a:Nat.
(\ b:Nat.

// We need this to be polymorphic over all possible NatT's,
// which a and b take as their first argument

(\ NatT:*.

// Notice that b's NatT is different from a's NatT.
// a's NatT is the "base" one where the zero and succ carry over exactly
// But b's succ actually needs to be represent multiplying by a.

b {\:NatT.NatT} (a NatT)

/*

We can see this more clearly by examining (a NatT)'s and (b SomeType)'s type:

For (a NatT):

{\ NatT1:*.
{\ succ:{\:NatT1.NatT1}.
{\ zero:NatT1.
NatT1
}}} NatT

  reducing to the following after 1 beta reduction,

{\ succ:{\:NatT.NatT}.
{\ zero:NatT.
NatT
}}

For (b SomeType) it's the same:

{\ succ:{\:SomeType.SomeType}.
{\ zero:SomeType.
SomeType
}}

Now for the types to be correct, we need (a NatT)'s type to match (b SomeType)'s argument's type.

{\ succ:{\:NatT.NatT}.
{\ zero:NatT.
NatT
}}

==

{\:SomeType.SomeType}

And this can only be done if SomeType == {\:NatT.NatT}

{\    :{\:NatT.NatT}.{\    :NatT.NatT}}
{\succ:{\:NatT.NatT}.{\zero:NatT.NatT}} // Filling in the unused variables

*/

)

))
